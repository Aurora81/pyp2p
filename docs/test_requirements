* Determine whether behind a NAT or a DMZ
    * Code currently assumes NAT for everyone and tries to forward but it would be helpful to know if they're behind a router before starting the passive server

* There should be a way to test arbitrary networking configurations for Net on a host running the networking client.
* There should be a way to instruct a host to unl.connect to another host.
    * This might also require manipulating the other host's UNL to give to the host making the connection to support arbitrary tests.
        * Every host has two UNLs: the actual UNL indicating its network details and a simulated UNL (for testing say: tcp hole punching amongst nodes.)
            * You should be able to initialize the Net class with manual details for passive open (node type)
            * You should be able to initialize the Net class with manual details for simultaneous open (tests NAT type if its specified.)
                * If the actual node type is passive: a manual initialization of simultaneous should take priority.
* Nodes should check if they're registered with the test_server by hashing their mac address of their default interface to produce a username and generating a random password to the disk: if they're not registered - nodes should start a sample direct_net instance and send the resulting UNL details to the test_server
* The test client should check for new test requests from the test server every 5 seconds.
* The test server should schedule tests based on the sequential results of test clients: i.e. since making a connection first depends on setting up the networking stack on the target - the server should send commands to the target first and wait for a response before scheduling the connection.


* The test server should have a simple API + GUI using a bottle.py server
* The test server will use a simple in memory database (dicts and lists)
* The test server will be twisted, line receiver
* The test client will be twisted, line receiver (asynch)
* Test requests will be saved into a simple sqlite db
* Every test will be given an ID used for the client-server protocol
* If connection requests fail in response to a test: the client uploads the error.log to the test server with an associated test id
    * Exceptions in the test client are also wild card logged and written to the log so the client is stable no matter what.
        * Logging logs the line number, exception details and everything

* There needs to be a way to swap in new code if the software fails so testing can be done
* Error log cleared before each test



Unit tests:
* Unit tests can't be easily done without the test client and not for tcp hole punching but once the NAT vs DMZ status is known the dynamics of passive + port forwarding can be tested without manually doing tests with the test client. This will also require hosting a direct_net instance running a passive server on a VPS.


